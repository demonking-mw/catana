# Watan++: Catan AI Project Plan

## 1. Strategy & Approaches

### Approach 1: Machine Learning (ML)
*   **Concept:** Train a model to predict everything.
*   **Pros:** Cheap to run (inference).
*   **Cons:** Expensive to train, requires massive dataset.

### Approach 2: Artificial Intelligence (AI)
*   **Concept:** Logic-based reasoning and search.
*   **Pros:** Potentially best performance due to reasoning capabilities; cheaper to train.
*   **Cons:** Expensive to predict (inference compute).

### Approach 3: Analog / Heuristic
*   **Concept:** Hard-coded rules and heuristics.
*   **Pros:** Fast.
*   **Cons:** Hardest to implement well; lacks flexibility; rigid.

### Desired Strategy
**Hybrid AI/ML:** Mainly AI-driven (reasoning/search) with ML features for pattern recognition and probability maps. Multi-agent architecture is the preferred direction.

---

## 2. Player Modelling

To effectively play against humans, the AI must model opponent behavior:

*   **Noise:** frequency of suboptimal choices.
*   **Lag:** Accuracy of their perception relative to the current board state.
*   **Risk Tolerance:** Willingness to hold cards (e.g., holding >7 cards) or take risks.
*   **Play Style:** Preference for Road building vs. OWS (Ore-Wheat-Sheep) / Cities.
*   **Trade Behavior:**
    *   **Intensity:** Frequency of offers/accepting trades.
    *   **Balance/Urgency:** Do they trade for immediate action vs. long-term value? Do they take bad trades to unblock themselves? Are they impatient?
*   **Tracking:** How accurately do they track opponent hands, anticipate Road Building (RB) plays, or dodge Monopolies?
*   **Psychology/Meta:** Ability to table-talk ("Aura"), dissuade robbers, etc.

---

## 3. Model Architecture

### Settlement Logic Structure
*(Note: Numbers are placeholders)*

The settlement decision process is a pipeline of evaluators:

1.  **Settle Options (Generator)**
    *   Use math and AI to generate a list of reasonable settlement spots.
2.  **Simple Settle Predictor (Fast Simulation)**
    *   **Input:** Board state.
    *   **Process:** Simulates how the board fills up after a chosen settlement.
    *   **Output:** Settled locations and likelihoods.
    *   **Tech:** Fast, non-AI algorithm.
3.  **Simple Settle Evaluator (Heuristic)**
    *   **Input:** Board state (after first 8 settles).
    *   **Process:** Estimates advantage based on resources, production, and vulnerability (robber).
    *   **Tech:** Fast, non-AI heuristic.
4.  **Settle Evaluator (Deep Analysis)**
    *   **Input:** Board state.
    *   **Process:** Detailed analysis of win rates, conditions, races, and trading values across roll combinations.
    *   **Tech:** Expensive, uses Math + AI.

**Workflow:**
1.  Get reasonable options using *Settle Options*.
2.  For each option, use *Simple Settle Predictor* to simulate end-of-phase board states (keep top 50 scenarios).
3.  Run *Settle Evaluator* on the top 10 outcomes.
4.  Run *Simple Settle Evaluator* on the remaining outcomes.
5.  Normalize probabilities and calculate Expected Value (EV) win rate.
6.  Select the option with the highest EV.

### Knowledge Requirements
*   **Inference:** How to conclude facts from a database of implications cheaply.
*   **Board Understanding:** Converting board state (image or data) into semantically meaningful context.
*   **Opponent Prediction:** We need a model to predict where others will settle.
    *   *Solution:* A Probability Map generated by an ML model (similar concept to YOLO/CNN for pattern recognition on the board).

---

## 4. Data Structure & Design

### Requirements
*   **Efficiency:** Easy, cheap, and optimized for AI ingestion (token-efficient).
*   **Context:** "Cheap explanation" or *Semantic Compression*â€”requires fewer tokens for the AI to understand the game state.
*   **Database Integration:** Structured for easy storage and retrieval.
*   **Uncertainty Handling:** Must capture probabilistic data (e.g., card/dev card uncertainties, "unplayed dev" tracking). *Note: The structure stores probabilities; logic updates them.*

### Spec: High-Density Catan State (HDCS)
This structure is designed to strictly adhere to requirements (Card-level probability tracking, Dice history, Unplayed Dev tracking) while maintaining "Semantic Compression".

#### 1. Core Data Structure (JSON Payload)
*   **Dice History:** Queue of last 8 sums.
*   **Global Tracking:** `dev_rem` tracks global odds of drawing specific Dev cards.
*   **Card-Level Granularity:** Tracks **specific unknown cards** in a player's hand using tuples.
*   **Tuple Logic:**
    *   **Resource:** `[P_Wood, P_Brick, P_Wool, P_Grain, P_Ore]`
    *   **Dev Card:** `[Age, P_Knight, P_VP, P_Road, P_Year, P_Mono]`
*   **Board Representation (Dual Graph):**
    *   **Tiles:** Primary unit, including Ocean. identified by ID (0-36).
    *   **Nodes (Settlements):** Defined by the 3 adjacent tiles `[T1, T2, T3]`.

#### Board Definition Example
![alt text](board_defn.jpg)

```json
{
  // Note: VP=Victory Point, RB=Road Building, YOP=Year of Plenty, MONO=Monopoly
  // Assume: I am player 0
  "meta": {
    "t": 45,                  // Current Turn
    "p_curr": 1,              // Active Player ID
    "phase": "main",          // main=in-game, settle=pre-game settlement
    
    // HISTORY: Last 8 rolls (Newest -> Oldest)
    "dice": [7, 4, 6, 8, 11, 3, 5, 9],
    
    // GLOBAL TRACKER: Cards NOT YET PLAYED (Deck + All Hands)
    // [Knight, VP, RB, YOP, MONO]
    "dev_rem": [5, 2, 1, 0, 0] 
  },

  "map": {
    "robber": 18, // Tile ID of the robber
    
    // STATIC BOARD DATA (Layout)
    // Tiles: List of [ResourceID, NumberToken] indexed by TileID (0-36).
    // Each entry is a pair because a tile has both a Resource Type AND a Dice Number.
    // Examples: [5, 0] = Desert, [6, 0] = Ocean, [4, 6] = Ore with a 6.
    // ResourceIDs: 0=Wood, 1=Brick, 2=Wool, 3=Grain, 4=Ore, 5=Desert, 6=Ocean
    // NumberToken: 0=Desert/Ocean, -1=Port, 2-12=Dice Number.
    // If NumberToken is -1 (Port), ResourceID indicates port type:
    // [0, -1]=Wood Port, [1, -1]=Brick Port, [5, -1]=General (3:1) Port.
    // IDs 0-36 follow the specific layout (Ocean outer ring -> Center)
    "tiles": [
        [6, 0], [6, 0], [5, -1], ... [4, 6], ... // 0=Ocean, 2=General Port, ...
    ],
    // Ports: Map of NodeTuple -> PortType 
    // Key: "T1_T2_T3" (Sorted Tile IDs of the settlement spot)
    // PortType: 0-4 (2:1 Specific Resource), 5 (3:1 Any)
    // Port Locations (Pairs of Access Spots): 
    // [{0_1_5, 0_4_5}, {1_2_6, 2_6_7}, {7_8_13, 8_13_14}, {14_20_21, 20_21_27}, 
    //  {26_27_32, 26_31_32}, {30_31_35, 30_34_35}, {28_29_33, 29_33_34}, 
    //  {16_22_23, 22_23_28}, {4_9_10, 9_10_16}]
    "ports": {
        // 3:1 Ports (Type 5)
        "0_1_5": 5, "0_4_5": 5,
        "14_20_21": 5, "20_21_27": 5,
        "28_29_33": 5, "29_33_34": 5, 
        "4_9_10": 5, "9_10_16": 5,

        // 2:1 Ports (Types 0=Wood, 1=Brick, 2=Wool, 3=Grain, 4=Ore)
        "1_2_6": 2, "2_6_7": 2,       // Wool
        "7_8_13": 4, "8_13_14": 4,    // Ore
        "26_27_32": 3, "26_31_32": 3, // Grain
        "30_31_35": 1, "30_34_35": 1, // Brick
        "16_22_23": 0, "22_23_28": 0  // Wood
    },

    // DYNAMIC STATE
    // Nodes: "T1_T2_T3" (Sorted) -> [PlayerID, BuildingType]
    // BuildingType: 1=Settlement, 2=City
    "nodes": { "4_5_10": [0, 1], "10_11_17": [1, 2] }, 
    
    // Edges: "T1_T2" (Sorted) -> PlayerID
    "edges": { "4_5": 0, "5_10": 0 }
  },

  "players": [
    // PLAYER 0 (ME - Perfect Information)
    {
      "id": 0,
      "public": [5, 0, 6, 4],  // [VP, Army, Road_Len, Res_Count]
      
      // KNOWN RESOURCES (Integer Counts)
      // [Wood, Brick, Wool, Grain, Ore]
      "res_k": [2, 0, 1, 3, 0],
      
      // UNKNOWN RESOURCES (Empty for me)
      "res_u": [],
      
      // DEV CARDS (My Hand)
      // [Age, Knight, VP, Road, Year, Mono]
      "devs": [
        [3, 1.0, 0, 0, 0, 0], // A Knight bought 3 turns ago
        [0, 0, 1.0, 0, 0, 0]  // A VP just bought (Age 0)
      ]
    },

    // PLAYER 1 (OPPONENT - Probabilistic)
    {
      "id": 1,
      "public": [4, 1, 4, 3], 
      
      // KNOWN RESOURCES (Facts)
      "res_k": [0, 0, 1, 0, 0], 
      
      // UNKNOWN RESOURCES (Card-Level Probability)
      // They have 2 unknown cards. Each is a 5-tuple probability.
      // [P_Wood, P_Brick, P_Wool, P_Grain, P_Ore]
      "res_u": [
        // Card A: Likely Ore
        [0.1, 0.0, 0.1, 0.1, 0.7], 
        // Card B: Random distribution
        [0.2, 0.2, 0.2, 0.2, 0.2]
      ],
      
      // DEV CARDS (Hidden Hand)
      // [Age, P_Knight, P_VP, P_Road, P_Year, P_Mono]
      "devs": [
        // Held for 12 turns. Likely VP or Monopoly
        [12, 0.1, 0.6, 0.0, 0.0, 0.3]
      ]
    }
  ]
}
```

#### 2. Context Injection (System Prompt)
Inject this schema definition into the System Prompt so the AI understands compliance:

> "You are a Catan Engine. Interpret the Game State JSON as follows:
> 1. **Arrays are positional.** Do not hallucinate keys.
>    * res index: 0:Wood, 1:Brick, 2:Wool, 3:Grain, 4:Ore
>    * dev index: 0:Knight, 1:VP, 2:Road, 3:Year, 4:Mono
> 2. **Dice:** List of last 8 sums (Index 0 is most recent).
> 3. **Player res_u (Unknown Resources):** A list of tuples. Each tuple represents ONE specific card in the player's hand and the probability of it being each resource type.
> 4. **Player devs:** A list of tuples. Each tuple is ONE card: [Age_in_Turns, Prob_Knight, Prob_VP, Prob_Road, Prob_Year, Prob_Mono].
> 5. **Map Data (Dual Graph):**
>    *   **Tiles:** List of `[ResourceID, Number]`. IDs 0-36. 
>        *   Resource 6 = Ocean. Number 0 = Ocean/Desert.
>        *   Number -1 = Port. ResourceID indicates Type of Port (0-4=2:1, 5=3:1).
>    *   **Nodes (Settlements):** Keys are `T1_T2_T3` (Sorted Tile IDs).
>    *   **Edges (Roads):** Keys are `T1_T2` (Sorted Tile IDs).
>    *   **Ports:** Keys are Node IDs (`T1_T2_T3`) where the port exists. PortType 0-4 = 2:1, 5 = 3:1."

#### 2a. Board Topology & Coordinate System
The board uses a **Vertex-Face Dual Graph** rather than Axial/Cube coordinates.
*   **Tiles (Faces):** 37 Hexes (IDs 0-36).
    *   **Structure:** Includes the 19 Resource Tiles AND the surrounding ring of 18 Ocean Tiles.
    *   **Row-Major Indexing:**
        *   Row 0: 0-3 (Ocean)
        *   Row 1: 4 (Ocean), 5-7 (Res), 8 (Ocean)
        *   ...
        *   Row 6: 33-36 (Ocean)
*   **Nodes (Intersections):** Defined strictly by the **Ordered Tuple of 3 Adjacent Tile IDs**.
    *   *Example:* Settlement at `[4, 5, 10]`.
    *   *Validity:* Any set of 3 mutually adjacent tiles is a valid node (excluding 3-Ocean sets).
*   **Edges (Roads):** Defined strictly by the **Ordered Tuple of 2 Adjacent Tile IDs**.
    *   *Example:* Road between `[4, 5]`.
    *   *Validity:* Any pair of adjacent tiles is a road, UNLESS both tiles are Ocean (Bridge).


#### 3. Python Implementation (Pydantic Models)
Validates "Mixed Type" logic (Known vs. Unknown) for DB and AI.

```python
from pydantic import BaseModel, Field, field_validator
from typing import List, Dict, Union, Optional

# --- TYPE DEFINITIONS ---

# Tuple: [P_Wood, P_Brick, P_Wool, P_Grain, P_Ore]
# Represents probability of an unknown card being a specific resource.
# Example: [0.1, 0.0, 0.1, 0.1, 0.7] (Likely Ore)
ResProbTuple = List[float]

# Tuple: [Age, P_Knight, P_VP, P_Road, P_Year, P_Mono]
# Age in turns held. Probabilities sum to 1.0 (unless Age=0, then 0.0 until next turn).
# Example: [3, 1.0, 0.0, 0.0, 0.0, 0.0] (Known Knight bought 3 turns ago)
# Example: [12, 0.1, 0.6, 0.0, 0.0, 0.3] (Old hidden card, likely VP)
DevCardTuple = List[Union[int, float]]

# --- SUB-MODELS ---

class PlayerState(BaseModel):
    id: int
    # [VP, Army, Road_Len, Res_Count]
    # Example: [5, 0, 6, 4]
    public: List[int]
    
    # Known Resources (Integer counts)
    # Index: 0=Wood, 1=Brick, 2=Wool, 3=Grain, 4=Ore
    # Example: [2, 0, 1, 3, 0] (2 Wood, 1 Wool, 3 Grain)
    res_k: List[int]
    
    # Unknown Resources (List of probability tuples)
    # One tuple per unknown card in hand.
    # Example: See ResProbTuple
    res_u: List[ResProbTuple]
    
    # Dev Cards Hand (List of card tuples)
    # Example: See DevCardTuple
    devs: List[DevCardTuple]

class MapState(BaseModel):
    robber: int  # Tile ID (0-36)
    
    # Static Data
    # List of [ResourceID, NumberToken] indexed by TileID (0-36)
    # ResourceIDs: 0=Wood, 1=Brick, 2=Wool, 3=Grain, 4=Ore, 5=Desert, 6=Ocean
    # NumberToken: 0=Desert/Ocean, -1=Port, 2-12=Dice Number
    # Example Entry: [6, 0] (Ocean), [4, 6] (Ore, 6-pip), [0, -1] (Wood Port)
    tiles: List[List[int]] 
    
    # Key: "T1_T2_T3" (Sorted Tile IDs) -> PortType
    # PortType: 0-4 (2:1 Specific Resource [W,B,L,G,O]), 5 (3:1 Any)
    # Example: "0_1_5": 5 (3:1 Port at intersection of tiles 0, 1, 5)
    ports: Dict[str, int]
    
    # Dynamic State
    # Key: "T1_T2_T3" (Sorted) -> [PlayerID, BuildingType]
    # BuildingType: 1=Settlement, 2=City
    # Example: "4_5_10": [0, 1] (Player 0 built Settlement at 4-5-10)
    nodes: Dict[str, List[int]] = Field(default_factory=dict)
    
    # Key: "T1_T2" (Sorted) -> PlayerID
    # Example: "4_5": 0 (Player 0 built Road between tiles 4 and 5)
    edges: Dict[str, int] = Field(default_factory=dict)

class MetaState(BaseModel):
    t: int       # Current Turn (e.g., 45)
    p_curr: int  # Active Player ID (e.g., 1)
    phase: str   # "main", "settle"
    
    # Last 8 dice sums (Newest -> Oldest)
    # Example: [7, 4, 6, 8, 11, 3, 5, 9]
    dice: List[int]
    
    # Cards NOT YET PLAYED (Deck + All Hands)
    # [Knight, VP, RB, YOP, MONO]
    # Example: [5, 2, 1, 0, 0]
    dev_rem: List[int]

# --- ROOT MODEL ---

class GameState(BaseModel):
    meta: MetaState
    map: MapState
    players: List[PlayerState]

    def to_ai_payload(self):
        # Optimization: Round floats to 2 decimals to save Tokens
        json_str = self.model_dump_json()
        return json_str
```

#### 4. Storage Strategy (SQLite)
Use Relational Table for metadata (fast lookup) and JSONB for state.

```sql
CREATE TABLE game_snapshots (
    -- Composite Primary Key
    game_id TEXT,
    turn_id INTEGER,
    
    -- Fast Access Metadata
    active_player INTEGER,
    dice_roll INTEGER, 
    
    -- The Full State (Compressed JSON)
    state_payload JSONB, 
    
    -- Analytics Hooks
    p1_win_prob REAL, 
    
    PRIMARY KEY (game_id, turn_id)
);
```

#### 5. Token Efficiency Analysis
*   **Decoupled Knowledge (`res_k` vs `res_u`):** Only send heavy probability tuples for cards that are truly unknown. As cards are played, `res_u` shrinks.
*   **Float Truncation:** Rounding to 2 decimals (e.g., 0.33) saves chars. High precision is not needed for AI inference.
*   **Positional Arrays:** Eliminating keys saves ~20 tokens per card.

---

## 5. Data Acquisition: Colonist.io Packet Sniffing

To build a live recorder for **Colonist.io**, we use a **JavaScript Injector** to intercept WebSocket traffic and convert it to HDCS.

### Architecture
1.  **Interceptor:** Monkey-patch `WebSocket` to read messages.
2.  **State Machine:** JS object tracking the board state from Deltas.
3.  **Exporter:** Sends clean JSON to local AI Agent (e.g., `localhost:5000`).

### Step 1: The Sniffer Script
(Run in Console or Tampermonkey)

```javascript
(function() {
    // 1. WebSocket Hook: Intercepts network traffic
    const OriginalWebSocket = window.WebSocket;

    window.WebSocket = function(url, protocols) {
        const ws = new OriginalWebSocket(url, protocols);
        ws.addEventListener('message', (event) => {
            try {
                const data = JSON.parse(event.data);
                processPacket(data);
            } catch (e) { /* Ignore non-JSON */ }
        });
        return ws;
    };

    // 2. The State Machine
    let hdcs_state = {
        meta: { turn: 0, phase: "init" },
        board: [],
        players: {}, 
        map_state: { nodes: {}, edges: {} }
    };

    // 3. Packet Processor
    function processPacket(packet) {
        if (packet.id === 'GAME_SETUP' || packet.type === 'init') {
            initializeBoard(packet.payload);
        }
        if (packet.id === 'UPDATE') {
            updateState(packet.payload);
        }
    }

    function initializeBoard(raw_data) {
        // Map TileTypes and Ports to HDCS format
        // Capture static board layout: Tiles (Res + Number) and Port Locations
        console.log("Initializing HDCS Board...");
    }

    function updateState(delta) {
        if (delta.action === 'BUILD_ROAD') {
            // Convert Hex coords to Tile Pair "T1_T2"
        }
        sendToAI(hdcs_state);
    }

    // 4. Exporter
    function sendToAI(state) {
        fetch('http://localhost:5000/update_state', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(state)
        }).catch(err => console.error("AI Agent offline"));
    }
    
    console.log("Colonist Sniffer Active...");
})();
```

### Step 2: Translation Layer (The "Rosetta Stone")
*   **Resource Mapping:** Colonist `[1..5]` -> HDCS `[0..4]` (`Enum - 1`).
*   **Coordinate Conversion:** Map Cube (q,r,s) coords to Tile ID (0-36).
    *   **Derive Components:** Calculate adjacent Tile IDs to form Node keys (`T_a_b_c`) and Edge keys (`T_a_b`).

### Step 3: Handling Hidden Information
Since we sniff Client traffic, we are bound by Fog of War.
*   **Strategy:** The Javascript recorder records **Events** (e.g., "Player 2 stole from Player 1").
*   **Backend Logic:** The Python AI maintains the `res_u` Probability Distributions using Bayesian updates (e.g., "Player 2 stole -> Remove 1 random from P1 `res_k`, Add 1 weighted tuple to P2 `res_u`").

### Step 4: Deployment
1.  **Python Server:** Flask app receiving JSON.
2.  **Browser:** Tampermonkey script on Colonist.io.

